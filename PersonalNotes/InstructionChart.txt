
Address Modes:
   Name                     Letters   Binary   How operand is treated
   ---------------------------------------------------------------------------
   immediate                i         0000     operand

   direct                   d         0001     Mem[operand]
   indirect                 dn        0010     Mem[Mem[operand]]

   register   direct        r         0011     Mem[register]
   register indirect        rn        0100     Mem[Mem[register]]

   indexed direct           xd        0101     Mem[r7 + operand]
   indexed indirect         xn        0110     Mem[Mem[r7 + operand]]
   indexed offset           xo        0111     Mem[Mem[r7] + operand]
   indexed deffered         xf        1000     Mem[Mem[operand] + r7]

   stack direct             sd        1001     Mem[SP + operand]
   stack indirect           sn        1010     Mem[Mem[SP + operand]]
   stack offset             so        1011     Mem[Mem[SP] + operand]

   stack indexed direct     sxd       1100     Mem[SP + r7 + operand]
   stack indexed indirect   sxn       1101     Mem[Mem[SP + r7 + operand]]
   stack indexed offset     sxo       1110     Mem[Mem[SP + r7] + operand]
   stack indexed deffered   sxf       1111     Mem[Mem[SP + operand] + r7]



Types of instructions:
   Legend:
         o: op code
         a: address mode
         b: whether working with high byte(1) or low byte(0) (only used by instructions that operate on bytes)
         r: the first register specified (usually destination register)
         s: the second register specified (usually source register 1)
         t: the third register specified (usually source register 2)
         i: immediate

   i-type:  immediate type: the following two bytes will be
            treated as an operand rather than another
            instruction

      10oo oooo aaaa brrr | iiii iiii iiii iiii

            notes: the first bit will always be a 1. Only op codes starting
                   with a 1 will use the next two bytes as an operand

   j-type:  jump type: the following two bytes will be
            treated as an operand rather than another
            instruction

      11oo oooo osss brrr | iiii iiii iiii iiii

   r0-type: no registers specified, pure opcode
      000o oooo oooo oooo

   r1-type: register one type: two byte opcode involving one register
      001o oooo oooo brrr

   r2-type: register three type: two byte opcode involving two registers
      010o oooo ooss srrr

   r3-type: register three type: two byte opcode involving three registers
      011o ooot ttss srrr


Name                 Mnemonic    Type    Op Code              Example               Example Pseudo Code       Example Binary
-------------------------------------------------------------------------------------------------------------------------------------------------
Load Word            LDW         i       1000 0000            LDW r1, r2, r         r1 = Mem[r2]              1000 0000 0011 0001 | 0000 0000 0000 0011
Load High Byte       LDH         i       1000 0001;b=1        LDH r5, 15, i         r5(high) = 15             1000 0001 0000 1101 | 0000 0000 0000 1111
Load Low Byte        LDL         i       1000 0001;b=0        LDL r2, 10, i         r2(low) = 10              1000 0001 0000 0011 | 0000 0000 0000 1010
Store Word           STW         i       1000 0010            STW r1, label, d      Mem[label] = r1           1000 0010 0001 0001 | ???? ???? ???? ????
Store High Byte      STH         i       1000 0011;b=1        STH r1, r2, rn        Mem[Mem[r2]](high) = r1   1000 0011 0100 1001 | 0000 0000 0000 0011
Store Low Byte       STL         i       1000 0011;b=0        STL r2, r5, r         Mem[r5](low) = r2         1000 0011 0011 0010 | 0000 0000 0000 0101

Halt Program         HLT         r0      0000 ... 0000        HLT                   /* Stop program */        0000 0000 0000 0000
No Operation         NOP         r0      0000 ... 0001        NOP                   /* No Operation */        0000 0000 0000 0001

Bitwise Add          ADD         r3      0110 001             ADD r1, r2, r3        r1 = r2 + r3              0110 0010 1101 0001
Bitwise Subtract     SUB         r3      0110 010             SUB r1, r2, r3        r1 = r2 - r3              0110 0100 1101 0001
Bitwise And          AND         r3      0110 011             AND r1, r2, r3        r1 = r2 & r3              0110 0110 1101 0001
Bitwise Or           OR          r3      0110 100             OR  r1, r2, r3        r1 = r2 | r3              0110 1000 1101 0001
Bitwise Xor          XOR         r3      0110 101             XOR r1, r2, r3        r1 = r2 ^ r3              0110 1010 1101 0001

Bitwise Not          NOT         r2      0100 0000 00         NOT r1, r2            r1 = ~r2                  0100 0000 0001 0001
Bitwise Neg          NEG         r2      0100 0000 01         NEG r1, r2            r1 = -r2                  0100 0000 0101 0001

Arith Shift Left     ASL         r3      0110 110             ASL r1, r2, r3        r1 = r2 << r3             0110 1100 1101 0001
Arith Shift Right    ASR         r3      0110 111             ASR r1, r2, r3        r1 = r2 >> r3             0110 1110 1101 0001
Logic Shift Right    LSR         r3      0111 000             LSR r1, r2, r3        r1 = r2 >>> r3 (java)     0111 0000 1101 0001
Rotate Left          RTL         r3      0111 001             RTL r1, r2, r3        r1 = r2 rotated by r3     0111 0010 1101 0001
Rotate Right         RTR         r3      0111 010             RTR r1, r2, r3        r1 = r2 rotated by r3     0111 0100 1101 0001
Rotate Left Carry    RLC         r3      0111 011             RLC r1, r2, r3        r1 = r2 rotated by r3     0111 0110 1101 0001
Rotate Right Carry   RRC         r3      0111 100             RRC r1, r2, r3        r1 = r2 rotated by r3     0111 1000 1101 0001

Jump Unconditional   JMP         j       1100 0000 0          JMP label             goto label                1100 0000 0000 0000 | ???? ???? ???? ????
Jump Less Than       JLT         j       1100 0000 1          JLT r1, r2, label     goto if r1 < r2           1100 0000 1010 0001 | ???? ???? ???? ????
Jump Greater Than    JGT         j       1100 0001 0          JGT r1, r2, label     goto if r1 > r2           1100 0001 0010 0001 | ???? ???? ???? ????
Jump Less Equal      JLE         j       1100 0001 1          JLE r1, r2, label     goto if r1 <= r2          1100 0001 1010 0001 | ???? ???? ???? ????
Jump Greater Equal   JGE         j       1100 0010 0          JGE r1, r2, label     goto if r1 >= r2          1100 0010 0010 0001 | ???? ???? ???? ????
Jump Equal           JEQ         j       1100 0010 1          JEQ r1, r2, label     goto if r1 == r2          1100 0010 1010 0001 | ???? ???? ???? ????
Jump Not Equal       JNE         j       1100 0011 0          JNE r1, r2, label     goto if r1 != r2          1100 0011 0010 0001 | ???? ???? ???? ????

Loop                 LOP         j       1100 0011 1          LOOP r1, label        goto if r1 != 0 (r1--)    1100 0011 1000 0001 | ???? ???? ???? ????

Call Procedure       CAL         j       1110 0000 0          CAL proc              move PC into Stack, goto  1110 0000 0000 0000 | ???? ???? ???? ????
Return from Proc     RET         j       1110 0000 1          RET                   get PC from Stack, goto   1110 0000 1000 0000 | ???? ???? ???? ????

Push word to stack   PUSH        r1      0010 0000 0010       PUSH r1               move r1 onto stack        0010 0000 0010 0001
Push byte (high)     PSHH        r1      0010 0000 0011;b=1   PSHH r1               move r1(high) to stack    0010 0000 0011 1001
Push byte (low)      PSHL        r1      0010 0000 0011;b=0   PSHL r1               move r1(low) to stack     0010 0000 0011 0001
Pop word from stack  POP         r1      0010 0000 0100       POP r1                move stack to r1          0010 0000 0100 0001
Pop byte (high)      POPH        r1      0010 0000 0101;b=1   POPH r1               pop byte to r1(high)      0010 0000 0101 1001
Pop byte (low)       POPL        r1      0010 0000 0101;b=0   POPL r1               pop byte to r1(low)       0010 0000 0101 0001
